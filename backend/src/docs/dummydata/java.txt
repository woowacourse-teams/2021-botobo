Java
java에서 String 클래스가 불변이어서 얻는 이점으로 무엇이 있을까요?
1. 멀티 쓰레딩 환경에서 값이 변하지 않는다 \n 2. String 자료형은 비밀번호나 개인 정보와 같은 민감한 정보를 담는데, 값이 변하면 보안상의 문제를 야기할 수 있다. \n 3. 해시 자료구조에서 String은 key로 자주 사용된다. 이 때 값이 변하면 예상치 못한 문제가 발생할 수 있다. \n 4. String Pool에서 관리하며 같은 String 값을 필요로 할 때 새로운 String을 생성하지 않고 재활용할 수 있다.
싱글톤 클래스란 무엇이고, 왜 사용될까요?
싱글톤 클래스란 인스턴스를 한 개만 생성할 수 있는 클래스를 말합니다.
double과 float 데이터 타입의 차이는 무엇일까요?
float형 데이터 타입은 메모리에서 4 바이트를 차지하고 double형 데이터 타입은 8 바이트를 차지합니다. 바이트 수의 차이가 생기는 이유는 정밀도 때문인데, float은 유효자릿수가 7이고, double은 유효자릿수가 16입니다. 따라서 실수를 더욱 정밀하게 다루고 싶다면 double형 데이터 타입을 사용해야합니다.
원시타입(primitive type)과 래퍼 클래스(wrapper class)는 어떤 점에서 다른가요?
1. 래퍼 클래스는 null 값을 가질 수 있지만, 원시타입은 null이 될 수 없다. \n 2. 컬렉션(Collection)에서 사용하기 위해서는 원시타입을 래퍼 클래스로 박싱해야한다. \n 3. 래퍼 클래스가 가지고 있는 값을 연산에 활용하기 위해서는 메서드를 사용하거나 값을 꺼내야한다.
추상 클래스와 인터페이스의 차이는 무엇일까요?
인터페이스는 메서드를 선언만하고 메서드의 구현체를 포함할 수 없지만, 추상 클래스는 구현체가 없는 추상 메서드를 포함하거나 구현체가 있는 일반적인 메서드를 포함합니다. 또 다른 차이점으로는 인터페이스를 구현한 클래스는 인터페이스에서 선언한 모든 메서드를 구현해야 하지만 추상 클래스를 상속 받은 클래스는 그 추상 클래스의 모든 메서드를 다시 구현할 필요가 없습니다. 마지막으로, 하나의 클래스는 여러 인터페이스를 구현할 수 있지만 상속은 하나의 추상 클래스로부터만 받을 수 있습니다.
checked exception과 unchecked exception의 차이가 무엇인가요?
Checked Exception은 컴파일 하는 과정에서 확인되는 예외입니다. 그 예외가 발생했을 경우에는 예외를 반드시 처리해야합니다. Unchecked Exception은 꼭 처리하지 않아도 되는 예외입니다. Checked Exception의 예시로는 IOException, 그리고 Unchecked Exception의 예시로는 Runtime Exception이 있습니다.
자바에서 접근제한자로 어떤 것들이 있나요?
public, protected, default, private 이 있습니다.
자바에서 변수에 final 키워드를 붙이면 어떻게 되나요?
변수가 final로 선언되면 그 변수의 값을 재할당할 수 없습니다. 마치 상수처럼 되어버립니다. 하지만 해당 변수에 할당된 객체의 상태는 변경될 수 있습니다.
상속을 써서 얻을 수 있는 이점이 무엇인가요?
같은 기능을 하는 클래스들이 있을 경우, 그 기능을 구현한 코드를 한 부모 클래스에 넣어 중복되는 코드를 줄이며 재사용 가능한 구조를 만들 수 있다는 이점이 있습니다.
Stack과 Queue의 차이를 간단하게 설명해주세요.
Stack과 Queue 둘 다 정보를 담는 자료구조임은 같습니다. 그러나 Stack은 마지막으로 넣은 자료를 가장 먼저 꺼낼 수 있는 Last In First Out (LIFO) 구조이며, Queue는 처음으로 넣은 자료를 먼저 꺼낼 수 있는 First In First Out (FIFO) 구조입니다.
인덱스(index)란 무엇인가요?
인덱스는 데이터분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 말한다. 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작 뿐만 아니라 레코드 접근과 관련하여 효율적인 순서 매김 동작에 대한 기초를 제공한다.
트랜잭션(Transaction)이란 무엇인가요?
하나의 논리적인 기능을 수행하기 위한 작업 단위로 데이터베이스의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.
관계형 데이터베이스 관리 시스템(RDBMS)를 정의하세요.
관계형 데이터베이스 관리 시스템 (RDBMS)은 데이터베이스에 별도의 테이블에 저장된 관계형 데이터 모델을 기반으로하며 공통 열의 사용과 관련이 있다. SQL (Structured Query Language)을 사용하여 관계형 데이터베이스에서 데이터에 쉽게 액세스 할 수 있다.
데이터베이스 무결성이란 무엇인가요?
데이터 베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 말합니다.
데이터베이스 정규화란 무엇인가요?
자료의 손실이나 불필요한 정보의 도입 없이 데이터의 일관성, 데이터 중복을 최소화하고 최대의 데이터 안정성 확보를 위한 안정적 자료 구조로 변환하기 위해서 하나의 테이블을 둘 이상을 분리하는 작업이다.
트랜잭션의 4가지 성질에 대해 설명해주세요.
Atomicity(원자성) 는 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.\nConsistency(일관성) 는 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.\nIsolation(독립성) 은 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.\nDurablility(지속성) 는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
데이터베이스에서 데드락(Dead Lock)이란 무엇인가요?
2개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 교착상태 라고 한다.
트랜잭션에서 격리 수준(Isolation Level)은 무엇이고 종류를 설명해주세요.
격리 수준은 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준을 말한다.\n\nRead Uncommitted(레벨 0): 한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션의 접근이 가능하다. 즉 커밋하지 않은 데이터를 읽을 수 있다. 해당 격리 수준은 모든 문제에서 발생 가능성이 존재하지만 처리 성능은 가장 높다.\nRead Committed(레벨 1): Committed가 완료된 데이터만 읽을 수 있다. 이는 Dirty Read가 발생할 여지가 없으나, Read Uncommitted 수준보다 동시 처리 성능은 떨어진다. 다만 Non-Repeatable Read, Phantom Read가 발생 가능하다. 데이터베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다.\nRepeatable Read(레벨 2): 트랜잭션 내에서 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 이는 개별 데이터 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만, 결과 집합 자체가 달라지는 Phantom Read는 발생 가능 하다.\nSerializable(레벨 3): 가장 엄격한 격리 수준. 3가지 문제점을 모두 커버할 수 있다. 다만 동시 처리 성능은 급격히 떨어질 수 있다.
데이터베이스 락(Lock)이란 무엇인가요?
데이터베이스 연산(read/write)을 수행하기 전에 해당 데이터에 먼저 lock 연산을 실행하여 독점권을 획득하는 방식으로 트랜잭션의 직렬가능성을 보장하는 방식이다. 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어한다. 기본 원리는 먼저 접근한 데이터에 대한 연산을 다 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호배제하여 직렬가능성을 보장하는 것이다.
COMMIT과 ROLLBACK에 대해 설명해주세요.
COMMIT은 해당 트랜잭션으로 반영된 데이터베이스 변경사항을 저장 하는 것이고 ROLLBACK은 해당 트랜잭션으로 반영된 데이터베이스 변경사항을 취소 하는 것이다.
인덱스(index)란 무엇인가요?
인덱스는 데이터분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 말한다. 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작 뿐만 아니라 레코드 접근과 관련하여 효율적인 순서 매김 동작에 대한 기초를 제공한다.
트랜잭션(Transaction)이란 무엇인가요?
하나의 논리적인 기능을 수행하기 위한 작업 단위로 데이터베이스의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.
관계형 데이터베이스 관리 시스템(RDBMS)를 정의하세요.
관계형 데이터베이스 관리 시스템 (RDBMS)은 데이터베이스에 별도의 테이블에 저장된 관계형 데이터 모델을 기반으로하며 공통 열의 사용과 관련이 있다. SQL (Structured Query Language)을 사용하여 관계형 데이터베이스에서 데이터에 쉽게 액세스 할 수 있다.
데이터베이스 무결성이란 무엇인가요?
데이터 베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 말합니다.
데이터베이스 정규화란 무엇인가요?
자료의 손실이나 불필요한 정보의 도입 없이 데이터의 일관성, 데이터 중복을 최소화하고 최대의 데이터 안정성 확보를 위한 안정적 자료 구조로 변환하기 위해서 하나의 테이블을 둘 이상을 분리하는 작업이다.
트랜잭션의 4가지 성질에 대해 설명해주세요.
Atomicity(원자성) 는 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.\nConsistency(일관성) 는 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.\nIsolation(독립성) 은 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.\nDurablility(지속성) 는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
데이터베이스에서 데드락(Dead Lock)이란 무엇인가요?
2개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 교착상태 라고 한다.
트랜잭션에서 격리 수준(Isolation Level)은 무엇이고 종류를 설명해주세요.
격리 수준은 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준을 말한다.\n\nRead Uncommitted(레벨 0): 한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션의 접근이 가능하다. 즉 커밋하지 않은 데이터를 읽을 수 있다. 해당 격리 수준은 모든 문제에서 발생 가능성이 존재하지만 처리 성능은 가장 높다.\nRead Committed(레벨 1): Committed가 완료된 데이터만 읽을 수 있다. 이는 Dirty Read가 발생할 여지가 없으나, Read Uncommitted 수준보다 동시 처리 성능은 떨어진다. 다만 Non-Repeatable Read, Phantom Read가 발생 가능하다. 데이터베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다.\nRepeatable Read(레벨 2): 트랜잭션 내에서 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 이는 개별 데이터 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만, 결과 집합 자체가 달라지는 Phantom Read는 발생 가능 하다.\nSerializable(레벨 3): 가장 엄격한 격리 수준. 3가지 문제점을 모두 커버할 수 있다. 다만 동시 처리 성능은 급격히 떨어질 수 있다.
데이터베이스 락(Lock)이란 무엇인가요?
데이터베이스 연산(read/write)을 수행하기 전에 해당 데이터에 먼저 lock 연산을 실행하여 독점권을 획득하는 방식으로 트랜잭션의 직렬가능성을 보장하는 방식이다. 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어한다. 기본 원리는 먼저 접근한 데이터에 대한 연산을 다 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호배제하여 직렬가능성을 보장하는 것이다.
COMMIT과 ROLLBACK에 대해 설명해주세요.
COMMIT은 해당 트랜잭션으로 반영된 데이터베이스 변경사항을 저장 하는 것이고 ROLLBACK은 해당 트랜잭션으로 반영된 데이터베이스 변경사항을 취소 하는 것이다.
인덱스(index)란 무엇인가요?
인덱스는 데이터분야에 있어서 테이블에 대한 동작의 속도를 높여주는 자료 구조를 말한다. 인덱스는 테이블 내의 1개의 컬럼, 혹은 여러 개의 컬럼을 이용하여 생성될 수 있다. 고속의 검색 동작 뿐만 아니라 레코드 접근과 관련하여 효율적인 순서 매김 동작에 대한 기초를 제공한다.
트랜잭션(Transaction)이란 무엇인가요?
하나의 논리적인 기능을 수행하기 위한 작업 단위로 데이터베이스의 일관된 상태를 또 다른 일관된 상태로 변환시키는 기능을 수행한다.
관계형 데이터베이스 관리 시스템(RDBMS)를 정의하세요.
관계형 데이터베이스 관리 시스템 (RDBMS)은 데이터베이스에 별도의 테이블에 저장된 관계형 데이터 모델을 기반으로하며 공통 열의 사용과 관련이 있다. SQL (Structured Query Language)을 사용하여 관계형 데이터베이스에서 데이터에 쉽게 액세스 할 수 있다.
데이터베이스 무결성이란 무엇인가요?
데이터 베이스에 저장된 데이터 값과 그것이 표현하는 현실 세계의 실제값이 일치하는 정확성을 말합니다.
데이터베이스 정규화란 무엇인가요?
자료의 손실이나 불필요한 정보의 도입 없이 데이터의 일관성, 데이터 중복을 최소화하고 최대의 데이터 안정성 확보를 위한 안정적 자료 구조로 변환하기 위해서 하나의 테이블을 둘 이상을 분리하는 작업이다.
트랜잭션의 4가지 성질에 대해 설명해주세요.
Atomicity(원자성) 는 트랜잭션의 연산이 DB에 모두 반영되던지 전혀 반영이되지 않던지 둘중에 하나만 수행해야한다.\nConsistency(일관성) 는 트랜잭션이 성공적으로 완료된 후에는 언제나 일관성 있는 DB상태로 변환되어야한다.\nIsolation(독립성) 은 수행중인 트랜잭션이 완전히 완료되기 전에는 다른 트랙잭션에서 수행 결과를 참조할 수 없다.\nDurablility(지속성) 는 성공적으로 완료된 트랜잭션의 결과는 시스템이 고장나더라도 영구적으로 반영되어야 한다.
데이터베이스에서 데드락(Dead Lock)이란 무엇인가요?
2개 이상의 트랜잭션이 특정 자원(테이블 또는 행)의 잠금(Lock)을 획득한 채 다른 트랜잭션이 소유하고 있는 잠금을 요구하면 아무리 기다려도 상황이 바뀌지 않는 상태가 되는데 이를 교착상태 라고 한다.
트랜잭션에서 격리 수준(Isolation Level)은 무엇이고 종류를 설명해주세요.
격리 수준은 트랜잭션에서 일관성이 없는 데이터를 허용하도록 하는 수준을 말한다.\n\nRead Uncommitted(레벨 0): 한 트랜잭션에서 커밋하지 않은 데이터에 다른 트랜잭션의 접근이 가능하다. 즉 커밋하지 않은 데이터를 읽을 수 있다. 해당 격리 수준은 모든 문제에서 발생 가능성이 존재하지만 처리 성능은 가장 높다.\nRead Committed(레벨 1): Committed가 완료된 데이터만 읽을 수 있다. 이는 Dirty Read가 발생할 여지가 없으나, Read Uncommitted 수준보다 동시 처리 성능은 떨어진다. 다만 Non-Repeatable Read, Phantom Read가 발생 가능하다. 데이터베이스들은 보통 Read Committed를 디폴트 수준으로 지정한다.\nRepeatable Read(레벨 2): 트랜잭션 내에서 조회한 데이터를 반복해서 조회해도 같은 데이터가 조회된다. 이는 개별 데이터 이슈인 Dirty Read나 Non-Repeatable Read는 발생하지 않지만, 결과 집합 자체가 달라지는 Phantom Read는 발생 가능 하다.\nSerializable(레벨 3): 가장 엄격한 격리 수준. 3가지 문제점을 모두 커버할 수 있다. 다만 동시 처리 성능은 급격히 떨어질 수 있다.
데이터베이스 락(Lock)이란 무엇인가요?
데이터베이스 연산(read/write)을 수행하기 전에 해당 데이터에 먼저 lock 연산을 실행하여 독점권을 획득하는 방식으로 트랜잭션의 직렬가능성을 보장하는 방식이다. 병행 수행되는 트랜잭션들이 동일한 데이터에 동시에 접근하지 못하도록 lock과 unlock이라는 2개의 연산을 이용해 제어한다. 기본 원리는 먼저 접근한 데이터에 대한 연산을 다 마칠 때까지, 해당 데이터에 다른 트랜잭션이 접근하지 못하도록 상호배제하여 직렬가능성을 보장하는 것이다.